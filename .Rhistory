obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
#return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
library("identifyr", lib.loc="C:/Program Files/R/R-3.2.3/library")
detach("package:identifyr", unload=TRUE)
?clean_x
obtain_id(obtain = "X", using = "CASE", "PB021665")
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
new <- function(x) { ref[x,1]}
new(1)
new(2)
match("PB021665", ref[,"CASE"]
)
View(ref)
colnames(ref) <- c("X", "CII", "CASE")
match("PB021665", ref[,"CASE"])
obtain_id(obtain = "X", using = "CASE", "PB021665")
devtools::use_data(ref, internal = TRUE, overwrite = TRUE)
library(identifyr)
rm(obtain_id)
rm(new)
library(identifyr)
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
?clean_x
rm(ref)
clean_x("X00020", using = "CII", value = "A07515123")
document()
load_all()
library(identifyr)
?clean_pb
search()
library(identifyr)
?clean_pb
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
library(devtools)
document()
load_all
load_all()
library(identifyr)
?obtain_id
library(identifyr)
?obtain_id
?clean_x
document()
load_all()
library(identifyr)
library(identifyr)
document()
load_all()
library(identifyr)
library(identifyr)
?clean_x
?obtain_id
clean_x
document()
document()
load_all()
library(identifyr)
library(identifyr)
?clean_x
?obtain_id
?clean_id
library(identifyr)
?clean_x
?obtain_id
document()
?clean_x
?clean_pb
?clean_id
load("./R/sysdata.rda")
summary(ref)
rm(ref)
summary(ref)
ref <- read.csv("./R/ids.csv")
summary(ref)
colnames(ref) <- c("X", "CASE", "CII")  # rename the columns
ref$X <- as.character(ref$X)
ref$CASE <- as.character(ref$CASE)
ref$CII <- as.character(ref$CII)
summary(ref)
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", value = "A07515123")
colnames(ref) <- c("X", "CII", "CASE")  # rename the columns
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
rm(ref)
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
rm(obtain_id)
document()
library(devtools)
document()
load_all()
obtain_id("X", using = "CASE", value = "PB021665")
clean_x("X020", using = "CASE", value = "PB021665")
library(identifyr)
?obtain_id
?clean_x
document()
load_all()
?clean_x
?obtain_id
clean_x("X020", using = "CASE", value = "PB021665")
getwd()
document()
load_all
load_all
load_all()
?clean_x
clean_x("X00020", using = "CASE", value = "PB021665")
build()
document()
load_all()
build()
install_github("georgemirandajr/identifyr")
library(identifyr)
?clean_x
?clean_id
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
clean_x("X020", using = "CASE", "PB021665")
install.packages("ggplot2")
install.packages("xtable")
library(devtools)
document()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
build()
install_github("georgemirandajr/identifyr")
library(identifyr)
clean_case("PB02")
clean_pb("PB02")
?clean_case
library(identifyr)
?clean_case
?clean_id
clean_x <- function(x, using = NULL, value = "") {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 6, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("PB", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("PB000000", padded)] <- NA
# Return the final string
return(padded)
#   # Replace any instances where there is a space anywhere in the X number, such as "X 0000789"
#   x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
#
#   padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 9, side = "left", pad = "X")  # Pad the character vector and assign to a temporary list
#
#   # Replace X's with 0's when there's more than one X in an entry. Should only be X0, X00, X000, etc. Assign to new vector
#   clean.x <- stringr::str_replace_all(padded,
#                                       pattern = c(
#                                         "XXXXXXXXX{1}" = "X00000000",
#                                         "XXXXXXXX{1}" = "X0000000",
#                                         "XXXXXXX{1}" = "X000000",
#                                         "XXXXXX{1}" = "X00000",
#                                         "XXXXX{1}" = "X0000",
#                                         "XXXX{1}" = "X000",
#                                         "XXX{1}" = "X00",
#                                         "^XX" = "X0")
#   )
#
#   # Find entries that have non-X numbers such as "NO X #", "Not in APS", etc. Replace these with NA values
#   clean.x[grep("[A-Wa-w]\\D|[Y-Zy-z]\\D", clean.x)] <- NA
## If verify is TRUE, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("XA1234")
clean_x <- function(x, using = NULL, value = "") {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
# Return the final string
return(padded)
#   # Replace any instances where there is a space anywhere in the X number, such as "X 0000789"
#   x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
#
#   padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 9, side = "left", pad = "X")  # Pad the character vector and assign to a temporary list
#
#   # Replace X's with 0's when there's more than one X in an entry. Should only be X0, X00, X000, etc. Assign to new vector
#   clean.x <- stringr::str_replace_all(padded,
#                                       pattern = c(
#                                         "XXXXXXXXX{1}" = "X00000000",
#                                         "XXXXXXXX{1}" = "X0000000",
#                                         "XXXXXXX{1}" = "X000000",
#                                         "XXXXXX{1}" = "X00000",
#                                         "XXXXX{1}" = "X0000",
#                                         "XXXX{1}" = "X000",
#                                         "XXX{1}" = "X00",
#                                         "^XX" = "X0")
#   )
#
#   # Find entries that have non-X numbers such as "NO X #", "Not in APS", etc. Replace these with NA values
#   clean.x[grep("[A-Wa-w]\\D|[Y-Zy-z]\\D", clean.x)] <- NA
## If verify is TRUE, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("XA1234")
clean_x("678")
clean_x("X00020", using = "CII", value = "A07515123")
clean_x("X00A20", using = "CII", value = "A07515123")
clean_x <- function(x, using = NULL, value = "") {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
# Return the final string
# return(padded)
#   # Replace any instances where there is a space anywhere in the X number, such as "X 0000789"
#   x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
#
#   padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 9, side = "left", pad = "X")  # Pad the character vector and assign to a temporary list
#
#   # Replace X's with 0's when there's more than one X in an entry. Should only be X0, X00, X000, etc. Assign to new vector
#   clean.x <- stringr::str_replace_all(padded,
#                                       pattern = c(
#                                         "XXXXXXXXX{1}" = "X00000000",
#                                         "XXXXXXXX{1}" = "X0000000",
#                                         "XXXXXXX{1}" = "X000000",
#                                         "XXXXXX{1}" = "X00000",
#                                         "XXXXX{1}" = "X0000",
#                                         "XXXX{1}" = "X000",
#                                         "XXX{1}" = "X00",
#                                         "^XX" = "X0")
#   )
#
#   # Find entries that have non-X numbers such as "NO X #", "Not in APS", etc. Replace these with NA values
#   clean.x[grep("[A-Wa-w]\\D|[Y-Zy-z]\\D", clean.x)] <- NA
## If verify is TRUE, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("X00A20", using = "CII", value = "A07515123")
clean_x("678")
clean_x("X00020", using = "CII", value = "A07515123")
library(devtools)
load_all()
clean_x <- function(x, using = NULL, value = "") {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
# Return the final string
# return(padded)
#   # Replace any instances where there is a space anywhere in the X number, such as "X 0000789"
#   x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
#
#   padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 9, side = "left", pad = "X")  # Pad the character vector and assign to a temporary list
#
#   # Replace X's with 0's when there's more than one X in an entry. Should only be X0, X00, X000, etc. Assign to new vector
#   clean.x <- stringr::str_replace_all(padded,
#                                       pattern = c(
#                                         "XXXXXXXXX{1}" = "X00000000",
#                                         "XXXXXXXX{1}" = "X0000000",
#                                         "XXXXXXX{1}" = "X000000",
#                                         "XXXXXX{1}" = "X00000",
#                                         "XXXXX{1}" = "X0000",
#                                         "XXXX{1}" = "X000",
#                                         "XXX{1}" = "X00",
#                                         "^XX" = "X0")
#   )
#
#   # Find entries that have non-X numbers such as "NO X #", "Not in APS", etc. Replace these with NA values
#   clean.x[grep("[A-Wa-w]\\D|[Y-Zy-z]\\D", clean.x)] <- NA
## If verify is TRUE, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("X00020", using = "CII", value = "A07515123")
clean_x("X000A20", using = "CII", value = "A07515123")
clean_x("A000A20", using = "CII", value = "A07515123")
clean_x <- function(x, using = NULL, value = "") {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
## If the using argument is not null, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("A000A20", using = "CII", value = "A07515123")
clean_x("A000A20", using = "CII")
clean_x <- function(x, using = NULL, value = NULL) {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
## If the using argument is not null, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("A000A20", using = "CII")
clean_x("A000A20", using = "CII", value = "A07515123")
clean_x("X00020")
clean_x <- function(x, using = NULL, value = NULL) {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
## If the using argument is not null, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else if (!is.null(using) & is.null(value)) {
print("No value supplied to cross-reference")
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("X00020")
clean_x("A000A20", using = "CII")
?message
?warning
clean_x <- function(x, using = NULL, value = NULL) {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
## If the using argument is not null, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else if (!is.null(using) & is.null(value)) {
stop("No value supplied to cross-reference")
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("X00020")
clean_x("A000A20", using = "CII")
clean_x <- function(x, using = NULL, value = NULL) {
# Strip away all characters, even if it's something that indicates an empty value such as "No PB #"
x <- stringr::str_replace_all(x, pattern = "[A-Za-z]", replacement = "")
# Replace all whitespace
x <- stringr::str_replace_all(x, pattern = " ", replacement = "")
# Pad each element with zeros to become 6 digits long
padded <- vapply(x, stringr::str_pad, FUN.VALUE = "character", width = 8, side = "left", pad = "0")
# Add the PB prefix to all strings
padded <- stringr::str_c("X", padded)
# Convert the ones that originally used text to indicate null values to NA
padded[grep("X0000000", padded)] <- NA
## If the using argument is not null, use the reference table to verify the X numbers.
if (is.null(using)) {
# Return the cleaned up version of the character vector
return(padded)
} else if (!is.null(using) & is.null(value)) {
stop("The 'value' argument is null when 'using' argument is not null")
} else {
verified <- obtain_id(obtain = "X", using = using, value = value)
return(verified)
}
}
clean_x("X00020")
clean_x("A000A20", using = "CII", value = "A07515123")
clean_x("A000A20", using = "CII")
document()
library(testthat)
library(identifyr)
context("Match Output")
test_that("string is padding correctly when X is present", {
expect_output(clean_x("X6789"), "X00006789")
expect_output(clean_x("X"), "X00000000")
expect_output(clean_x("0"), "X00000000")
expect_output(clean_x("789"), "X00000789")
expect_output(clean_x("NOT IN APS"), NA)
expect_output(clean_x("NO X#"), NA)
expect_output(clean_x("X 0123456"), "X00123456")
expect_output(clean_x(" X01234"), "X00001234")
expect_output(clean_x("X01234 "), "X00001234")
expect_output(clean_x(" X 01234 "), "X00001234")
expect_output(clean_x(" X 012 34"), "X00001234")
})
clean_x("X")
test_that("string is padding correctly when X is present", {
expect_output(clean_x("X6789"), "X00006789")
expect_output(clean_x("X"), NA)
expect_output(clean_x("0"), NA)
expect_output(clean_x("789"), "X00000789")
expect_output(clean_x("NOT IN APS"), NA)
expect_output(clean_x("NO X#"), NA)
expect_output(clean_x("X 0123456"), "X00123456")
expect_output(clean_x(" X01234"), "X00001234")
expect_output(clean_x("X01234 "), "X00001234")
expect_output(clean_x(" X 01234 "), "X00001234")
expect_output(clean_x(" X 012 34"), "X00001234")
})
test_that("cross-reference works properly", {
expect_output(clean_x("A000A20", using = "CII", value = "A07515123"))
})
test_that("cross-reference works properly", {
expect_output(clean_x("A000A20", using = "CII", value = "A07515123"), "X00000020")
})
library(identifyr)
?clean_x
library(identifyr)
library(identifyr)
?clean_x
devtools::install_github("georgemirandajr/identifyr")
library(identifyr)
?clean_x
clean_x("X00A02", using = "CASE", "PB021665")
clean_x("X00A02", using = "CASE")
