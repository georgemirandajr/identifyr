"Rtools ", from_registry$version, " was previously installed in ",
from_registry$path, " but now that directory contains Rtools ",
installed_ver, ".\n\n",
"Please download and install ", rtools_needed(), " from ", rtools_url,
" and then run find_rtools().")
return(invisible(FALSE))
}
# Otherwise it must be ok :)
set_rtools_path(from_registry)
TRUE
}
scan_path_for_rtools <- function(debug = FALSE) {
if (debug) cat("Scanning path...\n")
# First look for ls and gcc
ls_path <- Sys.which("ls")
if (ls_path == "") return(NULL)
if (debug) cat("ls :", ls_path, "\n")
gcc_path <- Sys.which("gcc")
if (gcc_path == "") return(NULL)
if (debug) cat("gcc:", gcc_path, "\n")
# We have a candidate installPath
install_path <- dirname(dirname(ls_path))
install_path2 <- dirname(dirname(dirname(gcc_path)))
if (tolower(install_path2) != tolower(install_path)) return(NULL)
version <- installed_version(install_path, debug = debug)
if (debug) cat("Version:", version, "\n")
rtools(install_path, version)
}
scan_registry_for_rtools <- function(debug = FALSE) {
if (debug) cat("Scanning registry...\n")
keys <- NULL
try(keys <- utils::readRegistry("SOFTWARE\\R-core\\Rtools",
hive = "HCU", view = "32-bit", maxdepth = 2), silent = TRUE)
if (is.null(keys))
try(keys <- utils::readRegistry("SOFTWARE\\R-core\\Rtools",
hive = "HLM", view = "32-bit", maxdepth = 2), silent = TRUE)
if (is.null(keys)) return(NULL)
rts <- vector("list", length(keys))
for(i in seq_along(keys)) {
version <- names(keys)[[i]]
key <- keys[[version]]
if (!is.list(key) || is.null(key$InstallPath)) next;
install_path <- normalizePath(key$InstallPath,
mustWork = FALSE, winslash = "/")
if (debug) cat("Found", install_path, "for", version, "\n")
rts[[i]] <- rtools(install_path, version)
}
Filter(Negate(is.null), rts)
}
installed_version <- function(path, debug) {
if (!file.exists(file.path(path, "Rtools.txt"))) return(NULL)
# Find the version path
version_path <- file.path(path, "VERSION.txt")
if (debug) {
cat("VERSION.txt\n")
cat(readLines(version_path), "\n")
}
if (!file.exists(version_path)) return(NULL)
# Rtools is in the path -- now crack the VERSION file
contents <- NULL
try(contents <- readLines(version_path), silent = TRUE)
if (is.null(contents)) return(NULL)
# Extract the version
contents <- gsub("^\\s+|\\s+$", "", contents)
version_re <- "Rtools version (\\d\\.\\d+)\\.[0-9.]+$"
if (!grepl(version_re, contents)) return(NULL)
m <- regexec(version_re, contents)
regmatches(contents, m)[[1]][2]
}
is_compatible <- function(rtools) {
if (is.null(rtools)) return(FALSE)
if (is.null(rtools$version)) return(FALSE)
stopifnot(is.rtools(rtools))
info <- version_info[[rtools$version]]
if (is.null(info)) return(FALSE)
r_version <- getRversion()
r_version >= info$version_min && r_version <= info$version_max
}
rtools <- function(path, version) {
structure(list(version = version, path = path), class = "rtools")
}
is.rtools <- function(x) inherits(x, "rtools")
# Rtools metadata --------------------------------------------------------------
rtools_url <- "http://cran.r-project.org/bin/windows/Rtools/"
version_info <- list(
"2.11" = list(
version_min = "2.10.0",
version_max = "2.11.1",
path = c("bin", "perl/bin", "MinGW/bin")
),
"2.12" = list(
version_min = "2.12.0",
version_max = "2.12.2",
path = c("bin", "perl/bin", "MinGW/bin", "MinGW64/bin")
),
"2.13" = list(
version_min = "2.13.0",
version_max = "2.13.2",
path = c("bin", "MinGW/bin", "MinGW64/bin")
),
"2.14" = list(
version_min = "2.13.0",
version_max = "2.14.2",
path = c("bin", "MinGW/bin", "MinGW64/bin")
),
"2.15" = list(
version_min = "2.14.2",
version_max = "2.15.1",
path = c("bin", "gcc-4.6.3/bin")
),
"2.16" = list(
version_min = "2.15.2",
version_max = "3.0.0",
path = c("bin", "gcc-4.6.3/bin")
),
"3.0" = list(
version_min = "2.15.2",
version_max = "3.0.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.1" = list(
version_min = "3.0.0",
version_max = "3.1.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.2" = list(
version_min = "3.1.0",
version_max = "3.2.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.3" = list(
version_min = "3.2.0",
version_max = "3.3.99",
path = c("bin", "gcc-4.6.3/bin")
)
)
rtools_needed <- function() {
r_version <- getRversion()
for(i in rev(seq_along(version_info))) {
version <- names(version_info)[i]
info <- version_info[[i]]
ok <- r_version >= info$version_min && r_version <= info$version_max
if (ok) return(paste("Rtools", version))
}
"the appropriate version of Rtools"
}
v <- c("X01234 ", "NO X#", "X6789", "789")
clean_x(v)
devtools::document()
devtools::document()
find_rtools()
find_rtools()
v <- c("X01234 ", "NO X#", "X6789", "789")
clean_x(v)
devtools::document()
devtools::document()
devtools::document()
find_rtools()
?find_rtools
library(identifyr)
clean_x("X")
search()
library(identifyr)
clean_x("X")
?clean_x
devtools::document()
library(identifyr)
?clean_x
devtools::document()
library(identifyr)
clean_x("X")
?clean_x
df <- data.frame(xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")), pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"))
clean_id <- function(data, cols = list(...), FUN) {
data[,cols]
}
clean_id(df, cols = c(1,2))
clean_id(df, cols = c(1,3))
clean_id(df, cols = c(2,3))
library(magrittr)
df %>% clean_id(cols = c(2,3))
list <- c(1,2)
vapply(list, "=", 1:length(list))
vapply(list, "<-", 1:length(list))
list <- c(1,3)
for(i in 1:length(list)) { vapply(paste, df, "TADA")}
rm(i)
new <- df %>% clean_id(cols = c(1,3))
new
list[2]
list[1]
data[,list[2]]
data[,list[1]]
data[,unlist(list[1])]
df[,unlist(list[1])]
df[,list[1]]
vector1 <- df[,list[1]]
vector1
functions <- c("clean_x", "clean_pb")
?stop
length(list) == length(functions)
stopifnot(length(list) == length(functions))
cols <- list
rm(list)
vector1 <- df[,cols[1]]
vector1
functions[1]
func <- functions[1]
paste(func, "(", vector1, ")", collapse = "")
paste(func, "(", vector1, ")", sep = "")
all_functions <- c(clean_x, clean_pb)
vapply(df, `[`)
lapply(df, `[`)
result <- lapply(df, `[`)
length(result)
result[1,3]
result[c(1,3)]
result[cols]
result <- result[cols]
result
lapply(result, functions[1])
lapply(result, FUN = functions[1])
?as.name
as.name(func)
as.name(functions)
as.name(functions[2])
lapply(separated, FUN = as.name(possible_functions[1]))
lapply(separated, FUN = as.name(functions[1]))
library(identifyr)
?clean_x
lapply(result, FUN = functions[1])
lapply(result[1], FUN = functions[1])
temp <- list()
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
}
temp
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
return(temp)
}
temp
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
temp
}
temp
functions
functions[2]
cols
length(cols)
temp <- list()
functions
length(functions)
result[1]
result[2]
cols <- c(1,2)
result <- lapply(df, `[`)
result <- result[cols]
result
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
}
temp
length(temp)
unlist(temp)
length(unlist(temp))
temp
temp[1]
temp[[1]]
df[,1] <- temp[[1]]
clean_id <- function(data, cols = list(...), FUN = list(...)) {
stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df <- data.frame(xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")), pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"))
df
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
}  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
#   if (length(cols) != length(FUN)) {
#     stop("The number of columns specified must equal the number of functions supplied.")
#   } else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
# }
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1, 2), FUN = c("clean_x", "clean_pb"))
new
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
View(df)
rm(cols)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
rm(vector1)
cols <- c(1, 3)
possible_functions <- c("clean_pb", "clean_x")
separated <- lapply(df, `[`)
separated
separated <- separated[cols]
separated
temp <- list()
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
temp
data[,cols] <- temp[[1:2]]
data[,cols] <- temp[1:2]
data[,cols] <- temp
data[,cols]
cols
df[,cols]
df[,cols] <- temp
View(df)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
data[,cols] <- temp
return(data)
}
}
View(df)
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
?clean_x
devtools
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
Depends:
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?identifyr
library(identifyr)
?identifyr
?clean_id
library(identifyr)
library(devtools)
load_all()
load_all()
devtools::document()
install_github("georgemirandajr/identifyr")
devtools::document()
devtools::load_all()
devtools::check()
devtools::check()
library(identifyr)
devtools::release()
devtools::document()
devtools::use_build_ignore("NEWS.md"))
devtools::use_build_ignore("NEWS.md")
devtools::use_build_ignore("cran-comments.md")
devtools::use_build_ignore("identifyr-manual.pdf")
devtools::document()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
clean_id <- function(data, cols = list(), FUN = list()) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])  # apply the specified function to each element of the list
}
data[,cols] <- temp  # overwrite the original dataframe columns specified by the user with the cleaned version
return(data)  # return the final dataframe
}
}
devtools::document()
devtools::load_all()
clean_x("X01")
clean_pb("P01")
df <- data.frame(pbnum = c("PB123", "PB 0034", "  5678 ", "None"), status = c("Active", "Closed", "Closed", "Active"), xnum = c("X00123", "9512", "X789", "NOT IN APS"))
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
devtools::document()
devtools::document()
devtools::document()
devtools::release()
build_win()
devtools::release()
devtools::release()
