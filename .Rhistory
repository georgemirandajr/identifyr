cols <- c(1,2)
result <- lapply(df, `[`)
result <- result[cols]
result
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
}
temp
length(temp)
unlist(temp)
length(unlist(temp))
temp
temp[1]
temp[[1]]
df[,1] <- temp[[1]]
clean_id <- function(data, cols = list(...), FUN = list(...)) {
stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df <- data.frame(xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")), pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"))
df
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
}  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
#   if (length(cols) != length(FUN)) {
#     stop("The number of columns specified must equal the number of functions supplied.")
#   } else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
# }
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1, 2), FUN = c("clean_x", "clean_pb"))
new
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
View(df)
rm(cols)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
rm(vector1)
cols <- c(1, 3)
possible_functions <- c("clean_pb", "clean_x")
separated <- lapply(df, `[`)
separated
separated <- separated[cols]
separated
temp <- list()
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
temp
data[,cols] <- temp[[1:2]]
data[,cols] <- temp[1:2]
data[,cols] <- temp
data[,cols]
cols
df[,cols]
df[,cols] <- temp
View(df)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
data[,cols] <- temp
return(data)
}
}
View(df)
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
?clean_x
devtools
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
Depends:
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?identifyr
library(identifyr)
?identifyr
?clean_id
library(identifyr)
library(devtools)
load_all()
load_all()
devtools::document()
install_github("georgemirandajr/identifyr")
devtools::document()
devtools::load_all()
devtools::check()
devtools::check()
library(identifyr)
devtools::release()
devtools::document()
devtools::use_build_ignore("NEWS.md"))
devtools::use_build_ignore("NEWS.md")
devtools::use_build_ignore("cran-comments.md")
devtools::use_build_ignore("identifyr-manual.pdf")
devtools::document()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
clean_id <- function(data, cols = list(), FUN = list()) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])  # apply the specified function to each element of the list
}
data[,cols] <- temp  # overwrite the original dataframe columns specified by the user with the cleaned version
return(data)  # return the final dataframe
}
}
devtools::document()
devtools::load_all()
clean_x("X01")
clean_pb("P01")
df <- data.frame(pbnum = c("PB123", "PB 0034", "  5678 ", "None"), status = c("Active", "Closed", "Closed", "Active"), xnum = c("X00123", "9512", "X789", "NOT IN APS"))
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
devtools::document()
devtools::document()
devtools::document()
devtools::release()
build_win()
devtools::release()
devtools::release()
library(devtools)
dr_github()
getwd()
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr_0.1")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr_0.1")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
devtools::document()
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
library(identifyr)
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
devtools::install_github("georgemirandajr/identifyr")
devtools::install_github("georgemirandajr/identifyr")
devtools::install_github("georgemirandajr/identifyr")
library(identifyr)
?clean_x
?clean_id
?identifyr
View(df)
library(identifyr)
rm(clean_id)
library(identifyr)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_x", "clean_pb"))
clean_x("X001")
library(magrittr)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_x", "clean_pb"))
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
library(devtools)
devtools::document()
devtools::document()
library(identifyr)
devtools::release()
devtools::submit_cran()
library(devtools)
devtools::use_data(internal = TRUE)
ref <- read.csv("./R/ids.csv")
colnames(ref) <- c("X", "CASE", "CII")
ref$X <- as.character(ref$X)
ref$CASE <- as.character(ref$CASE)
ref$CII <- as.character(ref$CII)
devtools::use_data(internal = TRUE)
devtools::use_data(internal = TRUE, overwrite = TRUE)
?use_data
devtools::use_data(ref, internal = TRUE, overwrite = TRUE)
rm(ref)
devtools::use_data_raw()
devtools::document()
devtools::document()
devtools::load_all()
library(identifyr)
devtools::document()
devtools::load_all()
library(identifyr)
?clean_x
devtools::document()
devtools::load_all()
library(identifyr)
?obtain_id
library(identifyr)
?obtain_id
library(identifyr)
?clean_x
clean_x("X00294")
clean_x("X00294", using = "CASE", value = "PB024904")
load(file = "./R/sysdata.Rda")
tools::checkRdaFiles("./R/")
tools::checkRdaFiles("./R/sysdata.rda")
devtools::use_data(ref, internal = TRUE, compress = "bzip2")
devtools::use_data(ref, internal = TRUE, compress = "bzip2", overwrite = TRUE)
devtools::document()
devtools::load_all()
library(identifyr)
rm(ref, df)
library(identifyr)
?clean_x
library(identifyr)
?clean_x
library(identifyr)
?clean_x
?obtain_id
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
load("~/identifyr/R/sysdata.rda")
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
library(devtools)
use_data()
data("./R/sysdata.rda", envir = environment())
data("./data/sysdata.rda", envir = environment())
getwd()
data("./data/sysdata.rda", envir = environment())
rm(ref)
data("./data/sysdata.rda", envir = environment())
load("./data/sysdata.rda", envir = environment())
library(identifyr)
?ref
rm(ref)
library(identifyr)
?clean_x
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
sysdata
identifyr::sysdata
identifyr::sysdata.rda
identifyr::ref
load("./R/sysdata.rda")
class(ref)
use_data(ref, internal = TRUE, overwrite = TRUE, compress = "bzip2")
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
#return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
library("identifyr", lib.loc="C:/Program Files/R/R-3.2.3/library")
detach("package:identifyr", unload=TRUE)
?clean_x
obtain_id(obtain = "X", using = "CASE", "PB021665")
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", "PB021665")
new <- function(x) { ref[x,1]}
new(1)
new(2)
match("PB021665", ref[,"CASE"]
)
View(ref)
colnames(ref) <- c("X", "CII", "CASE")
match("PB021665", ref[,"CASE"])
obtain_id(obtain = "X", using = "CASE", "PB021665")
devtools::use_data(ref, internal = TRUE, overwrite = TRUE)
library(identifyr)
rm(obtain_id)
rm(new)
library(identifyr)
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
?clean_x
rm(ref)
clean_x("X00020", using = "CII", value = "A07515123")
document()
load_all()
library(identifyr)
?clean_pb
search()
library(identifyr)
?clean_pb
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
library(devtools)
document()
load_all
load_all()
library(identifyr)
?obtain_id
library(identifyr)
?obtain_id
?clean_x
document()
load_all()
library(identifyr)
library(identifyr)
document()
load_all()
library(identifyr)
library(identifyr)
?clean_x
?obtain_id
clean_x
document()
document()
load_all()
library(identifyr)
library(identifyr)
?clean_x
?obtain_id
?clean_id
library(identifyr)
?clean_x
?obtain_id
document()
?clean_x
?clean_pb
?clean_id
load("./R/sysdata.rda")
summary(ref)
rm(ref)
summary(ref)
ref <- read.csv("./R/ids.csv")
summary(ref)
colnames(ref) <- c("X", "CASE", "CII")  # rename the columns
ref$X <- as.character(ref$X)
ref$CASE <- as.character(ref$CASE)
ref$CII <- as.character(ref$CII)
summary(ref)
obtain_id <- function(obtain = list(), using = list(), value = "") {
# Use the reference data in the global environment
position <- match(value, ref[,using])  # find the row position of the value within the reference table
data <- ref[position,obtain]  # subset the reference table by the row position and return the column indicated by obtain
return(data)
}
obtain_id(obtain = "X", using = "CASE", value = "A07515123")
colnames(ref) <- c("X", "CII", "CASE")  # rename the columns
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
rm(ref)
obtain_id(obtain = "X", using = "CASE", value = "PB021665")
rm(obtain_id)
document()
library(devtools)
document()
load_all()
obtain_id("X", using = "CASE", value = "PB021665")
clean_x("X020", using = "CASE", value = "PB021665")
library(identifyr)
?obtain_id
?clean_x
document()
load_all()
?clean_x
?obtain_id
clean_x("X020", using = "CASE", value = "PB021665")
getwd()
document()
load_all
load_all
load_all()
?clean_x
clean_x("X00020", using = "CASE", value = "PB021665")
build()
document()
load_all()
build()
install_github("georgemirandajr/identifyr")
library(identifyr)
?clean_x
?clean_id
?obtain_id
obtain_id(obtain = "X", using = "CASE", "PB021665")
clean_x("X020", using = "CASE", "PB021665")
install.packages("ggplot2")
install.packages("xtable")
