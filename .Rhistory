structure(list(version = version, path = path), class = "rtools")
}
is.rtools <- function(x) inherits(x, "rtools")
# Rtools metadata --------------------------------------------------------------
rtools_url <- "http://cran.r-project.org/bin/windows/Rtools/"
version_info <- list(
"2.11" = list(
version_min = "2.10.0",
version_max = "2.11.1",
path = c("bin", "perl/bin", "MinGW/bin")
),
"2.12" = list(
version_min = "2.12.0",
version_max = "2.12.2",
path = c("bin", "perl/bin", "MinGW/bin", "MinGW64/bin")
),
"2.13" = list(
version_min = "2.13.0",
version_max = "2.13.2",
path = c("bin", "MinGW/bin", "MinGW64/bin")
),
"2.14" = list(
version_min = "2.13.0",
version_max = "2.14.2",
path = c("bin", "MinGW/bin", "MinGW64/bin")
),
"2.15" = list(
version_min = "2.14.2",
version_max = "2.15.1",
path = c("bin", "gcc-4.6.3/bin")
),
"2.16" = list(
version_min = "2.15.2",
version_max = "3.0.0",
path = c("bin", "gcc-4.6.3/bin")
),
"3.0" = list(
version_min = "2.15.2",
version_max = "3.0.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.1" = list(
version_min = "3.0.0",
version_max = "3.1.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.2" = list(
version_min = "3.1.0",
version_max = "3.2.99",
path = c("bin", "gcc-4.6.3/bin")
),
"3.3" = list(
version_min = "3.2.0",
version_max = "3.3.99",
path = c("bin", "gcc-4.6.3/bin")
)
)
rtools_needed <- function() {
r_version <- getRversion()
for(i in rev(seq_along(version_info))) {
version <- names(version_info)[i]
info <- version_info[[i]]
ok <- r_version >= info$version_min && r_version <= info$version_max
if (ok) return(paste("Rtools", version))
}
"the appropriate version of Rtools"
}
v <- c("X01234 ", "NO X#", "X6789", "789")
clean_x(v)
devtools::document()
devtools::document()
find_rtools()
find_rtools()
v <- c("X01234 ", "NO X#", "X6789", "789")
clean_x(v)
devtools::document()
devtools::document()
devtools::document()
find_rtools()
?find_rtools
library(identifyr)
clean_x("X")
search()
library(identifyr)
clean_x("X")
?clean_x
devtools::document()
library(identifyr)
?clean_x
devtools::document()
library(identifyr)
clean_x("X")
?clean_x
df <- data.frame(xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")), pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"))
clean_id <- function(data, cols = list(...), FUN) {
data[,cols]
}
clean_id(df, cols = c(1,2))
clean_id(df, cols = c(1,3))
clean_id(df, cols = c(2,3))
library(magrittr)
df %>% clean_id(cols = c(2,3))
list <- c(1,2)
vapply(list, "=", 1:length(list))
vapply(list, "<-", 1:length(list))
list <- c(1,3)
for(i in 1:length(list)) { vapply(paste, df, "TADA")}
rm(i)
new <- df %>% clean_id(cols = c(1,3))
new
list[2]
list[1]
data[,list[2]]
data[,list[1]]
data[,unlist(list[1])]
df[,unlist(list[1])]
df[,list[1]]
vector1 <- df[,list[1]]
vector1
functions <- c("clean_x", "clean_pb")
?stop
length(list) == length(functions)
stopifnot(length(list) == length(functions))
cols <- list
rm(list)
vector1 <- df[,cols[1]]
vector1
functions[1]
func <- functions[1]
paste(func, "(", vector1, ")", collapse = "")
paste(func, "(", vector1, ")", sep = "")
all_functions <- c(clean_x, clean_pb)
vapply(df, `[`)
lapply(df, `[`)
result <- lapply(df, `[`)
length(result)
result[1,3]
result[c(1,3)]
result[cols]
result <- result[cols]
result
lapply(result, functions[1])
lapply(result, FUN = functions[1])
?as.name
as.name(func)
as.name(functions)
as.name(functions[2])
lapply(separated, FUN = as.name(possible_functions[1]))
lapply(separated, FUN = as.name(functions[1]))
library(identifyr)
?clean_x
lapply(result, FUN = functions[1])
lapply(result[1], FUN = functions[1])
temp <- list()
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
}
temp
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
return(temp)
}
temp
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
temp
}
temp
functions
functions[2]
cols
length(cols)
temp <- list()
functions
length(functions)
result[1]
result[2]
cols <- c(1,2)
result <- lapply(df, `[`)
result <- result[cols]
result
for (i in 1:length(cols)) {
temp[i] <- lapply(result[i], FUN = functions[i])
}
temp
length(temp)
unlist(temp)
length(unlist(temp))
temp
temp[1]
temp[[1]]
df[,1] <- temp[[1]]
clean_id <- function(data, cols = list(...), FUN = list(...)) {
stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df <- data.frame(xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")), pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"))
df
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[1], FUN = possible_functions[1])
data[,i] <- temp[[i]]
}
return(data)
}
df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
# stopifnot(length(cols) != length(FUN))  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
View(new)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
}  # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
new <- df %>% clean_id(cols = c(1,2), FUN = c("clean_x", "clean_pb"))
new
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
stop("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
#   if (length(cols) != length(FUN)) {
#     stop("The number of columns specified must equal the number of functions supplied.")
#   } else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
# }
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
data[,i] <- temp[[i]]
}
return(data)
}
}
df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1), FUN = c("clean_x", "clean_pb"))
new <- df %>% clean_id(cols = c(1, 2), FUN = c("clean_x", "clean_pb"))
new
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
View(df)
rm(cols)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
rm(vector1)
cols <- c(1, 3)
possible_functions <- c("clean_pb", "clean_x")
separated <- lapply(df, `[`)
separated
separated <- separated[cols]
separated
temp <- list()
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
temp
data[,cols] <- temp[[1:2]]
data[,cols] <- temp[1:2]
data[,cols] <- temp
data[,cols]
cols
df[,cols]
df[,cols] <- temp
View(df)
clean_id <- function(data, cols = list(...), FUN = list(...)) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])
}
data[,cols] <- temp
return(data)
}
}
View(df)
df <- data.frame(pbnum = as.character(c("PB123", "PB 0034", "  5678 ", "None")), status = c("Active", "Closed", "Closed", "Active"), xnum = as.character(c("X00123", "9512", "X789", "NOT IN APS")))
df
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
?clean_x
devtools
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
devtools::test()
?clean_id
devtools::document()
Depends:
devtools::document()
devtools::test()
devtools::document()
devtools::test()
?identifyr
library(identifyr)
?identifyr
?clean_id
library(identifyr)
library(devtools)
load_all()
load_all()
devtools::document()
install_github("georgemirandajr/identifyr")
devtools::document()
devtools::load_all()
devtools::check()
devtools::check()
library(identifyr)
devtools::release()
devtools::document()
devtools::use_build_ignore("NEWS.md"))
devtools::use_build_ignore("NEWS.md")
devtools::use_build_ignore("cran-comments.md")
devtools::use_build_ignore("identifyr-manual.pdf")
devtools::document()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
clean_id <- function(data, cols = list(), FUN = list()) {
if (length(cols) != length(FUN)) {
warning("The number of columns specified must equal the number of functions supplied.")
} else { # make sure the specified columns equals the number of functions to apply
possible_functions <- FUN  # rename the list of functions
separated <- lapply(data, `[`)  # separate the original dataframe into a list containing each column as an element
separated <- separated[cols]  # select only the elements that relate to the columns being cleaned
temp <- list()  # initialize temporary container
for (i in 1:length(cols)) {
temp[i] <- lapply(separated[i], FUN = possible_functions[i])  # apply the specified function to each element of the list
}
data[,cols] <- temp  # overwrite the original dataframe columns specified by the user with the cleaned version
return(data)  # return the final dataframe
}
}
devtools::document()
devtools::load_all()
clean_x("X01")
clean_pb("P01")
df <- data.frame(pbnum = c("PB123", "PB 0034", "  5678 ", "None"), status = c("Active", "Closed", "Closed", "Active"), xnum = c("X00123", "9512", "X789", "NOT IN APS"))
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
devtools::document()
devtools::document()
devtools::document()
devtools::release()
build_win()
devtools::release()
devtools::release()
library(devtools)
dr_github()
getwd()
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr_0.1")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr_0.1")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
devtools::document()
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
library(identifyr)
dr_github(path = "C:/Users/e525902/Documents/identifyr-clone/identifyr")
devtools::install_github("georgemirandajr/identifyr")
devtools::install_github("georgemirandajr/identifyr")
devtools::install_github("georgemirandajr/identifyr")
library(identifyr)
?clean_x
?clean_id
?identifyr
View(df)
library(identifyr)
rm(clean_id)
library(identifyr)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_x", "clean_pb"))
clean_x("X001")
library(magrittr)
df %>% clean_id(cols = c(1, 3), FUN = c("clean_x", "clean_pb"))
df %>% clean_id(cols = c(1, 3), FUN = c("clean_pb", "clean_x"))
library(devtools)
devtools::document()
devtools::document()
library(identifyr)
devtools::release()
devtools::submit_cran()
library(devtools)
devtools::use_data(internal = TRUE)
ref <- read.csv("./R/ids.csv")
colnames(ref) <- c("X", "CASE", "CII")
ref$X <- as.character(ref$X)
ref$CASE <- as.character(ref$CASE)
ref$CII <- as.character(ref$CII)
devtools::use_data(internal = TRUE)
devtools::use_data(internal = TRUE, overwrite = TRUE)
?use_data
devtools::use_data(ref, internal = TRUE, overwrite = TRUE)
rm(ref)
devtools::use_data_raw()
devtools::document()
devtools::document()
devtools::load_all()
library(identifyr)
devtools::document()
devtools::load_all()
library(identifyr)
?clean_x
devtools::document()
devtools::load_all()
library(identifyr)
?obtain_id
library(identifyr)
?obtain_id
library(identifyr)
?clean_x
clean_x("X00294")
clean_x("X00294", using = "CASE", value = "PB024904")
load(file = "./R/sysdata.Rda")
tools::checkRdaFiles("./R/")
tools::checkRdaFiles("./R/sysdata.rda")
devtools::use_data(ref, internal = TRUE, compress = "bzip2")
devtools::use_data(ref, internal = TRUE, compress = "bzip2", overwrite = TRUE)
devtools::document()
devtools::load_all()
library(identifyr)
rm(ref, df)
library(identifyr)
?clean_x
library(identifyr)
